\documentclass{bmstu}
\usepackage{xparse}
\usepackage{comment}
\usepackage{amsmath} 
\setcounter{tocdepth}{3}
\setcounter{secnumdepth}{3}

%\lstset { %    
%	language=C++,    
%	backgroundcolor=\color{black!5}, % set backgroundcolor    
%	basicstyle=\footnotesize,% basic font setting
%	}

\lstset{
        inputencoding=utf8/koi8-r,
        basicstyle=\small\ttfamily,
        rulecolor=\color{black},
        escapeinside={\%*}{*)},
        breaklines=true,
        breakatwhitespace=true,
        tabsize=4,
        showstringspaces=false,
        float=h!,
        abovecaptionskip=-5pt,
        backgroundcolor=\color{black!5},
        frame=single,
}



\begin{document}

\tableofcontents
 



\chapter{Что такое компьютер}
\section{Немного истории}
Перед тем, как изучать языки программирования стоит понять ....

Для начала ответим на вопрос: "Что такое компьютер" ? Для повседневного обывателя это покажется очевидным, но давайте порасуждаем. 
Если обратится к свободным источникам(например к википедии), то мы увидем множество меканизмов. 
Саммым ранним компьютером я бы назвал антикитерский механизм. 
Всего лишь несколько десятков шестерёнок и магия простых чисел позволяло этому устройству предстакзыать лунные и солнечные затмения, движения небесных объектов и это при условии, что Земля была установлена, как центр отсчёта. 
При таком расположенни планеты, движения всех оставишся объектов перестовало быть простым объединением множества элемтических орбит. 
Так чтоже такое компьютер? Компьютер - это калькулятор. Даже сейчас, спустя полтысячелетия, компьютер остаётся сложным калькулятором, в основе которого стоит сложение, побитывые сдвиги и другие простые операции. 

Рассмотрим простой счётный механизм, состоящий из шетерёнок, рычагов и циферблатов. 
Для начала установим следующие правила: система счисления у нашего компьютера будет позиционной и, для удобства, оставим её десятичной, будет три поля для данных - два для входа и один для выхода. 
Тогда, выствавив два входных числа и использовав набор шестерёнок для передачи момента от входа к выходу, можно легко получить две простейших операции. 


\section{Диоды}

Начнём с самого простого --- с диодов. Диод --- это плоупроводник, содержащий в себе примесь, которая увеличивает 
или уменьшает количество свободных зарядов. 
Из школьного курса физики можно вспомнить, что диод пропускает ток только в одном направлении. 
Это несовсем верно, но пока приним за истину. 
Посмотрим на рисунок \ref{img:diod.png} и изучем, как ведут себя электроны в диоде при отсутствии внешнего питания. 
Слева зона богатая дырками (или носителями положительных зарядов), справа - электронами. 
Электроны могут перемещаться двумя способами: дрейфовый и диффузионный ток. 
Дрейфовый ток возникате из--за разницы потенциалов, диффузионный --- из--за разницы концентраций положительных и  отрицательных свободных зарядов.
На границе областей образуется запирающий слой. 
Этот слой не полволяет электорнам из n облости перейти в зону p.  

\includeimage
    {diod.png}
    {f}
    {H}
    {1\textwidth}
    {Диод}

Подключим питание: к p области подключим положительное питание, к области n --- отрицательное. 
Таким образом питание создаёт достаточное поле для образования дрейфового тока. Диод находится с открытом состоянии.
При противоположном подключении поле будет воздействовать на запирающий слой, расширяя его.
Рассмотрим вольт-амперную харатеристику на рисунке \ref{img:vah.jpg}. 
Как можно увидеть, при отрицательном напряжении появляется обратный ток. 
Поначалу он незначительный, но при большом напряжении этот ток резко возрастает и возникает пробой.
Хуже всего, если пробой тепловой. В таком случае устройство выходит из строя и больше не вернётся в рабочее состояние.
При других пробоях, при небольших временныйх интервалах устройство будет работуть корректно. 

\includeimage
    {vah.jpg}
    {f}
    {H}
    {1\textwidth}
    {Вольт-амперная характеристика}


\section{Транзисторы}

Если упрастить схему, то транзистор есть пара диодов, подключенных одноимёнными концами дрег к другу.
Из этого следует, что транзисторы могут быть двух видов: p-n-p и n-p-n типов.
У транзостора есть три ноги: эмитор, коллектор и база. 
Электроны движутся от эмитора к коллектору при обкрытом транзисторе.
Транзистор открывается, когда на базу транзистора n-p-n типа втикает в ток. 
Если трензистор p-n-p типа, то для открытия ток должен вытикать с базы.  

В современном мире бОльшая часть аппаратуры основана на Транзисторно-Транзисторной (ТТЛ) логике.
Транзистор играет роль ключю, позволяя перенаправлять ток и последовательно задействовать нужные Логические Элементы (ЛЭ).

\section{Простые логические элементы}

В булевой алгебре есть такие операции, как коньюкция (логическое умножение), дизъюнкия (логическое сложение) и отрицание. 
Но математика --- это матиматике, а как физически получить булевые функции для выполнения этих опаций.
Рассмотрим рисунк \ref{img:le.jpg}, на нём можно увидеть 3 логических элементов: логическое НЕ или инвертор, И-НЕ и ИЛИ-НЕ.

\includeimage
    {le.jpg}
    {f}
    {H}
    {1\textwidth}
    {Логические элементы}

Разберём работу инвертора, представленного на рисунке \ref{img:not.jpg} (остальные элементы предлагается разобрать читателям самостоятельно). 

\includeimage
    {not.jpg}
    {f}
    {H}
    {0.5\textwidth}
    {Логическое отрицание}

В инверторе используестся транзистор n-p-n типа, следовательно, когда через базу потечёт ток, транзистор откроется.
Пусть входное напраяжение на входе равно 0.
Тогда через базу ток не течёт и транзистор окажется в зактрытом состоянии.
Ток от коллектора к эммитору течь не будет и напряжение $E_K$, пройдя резистор $R_K$, сгененрирует выходное напряжение.
Тем самым, при подачи логического нуля на выходе получим логическую единицу.
Если подать на вход +5 вольт --- эквивалент логической единицы, то в базу начнёт втикать электрический ток и транзистор откроется. 
Тогда через транзитор потечёт ток и на выходе будет напряжение логического нуля.

\section{Память. Триггеры.}

Чтобы обработать какую-либо информацию, её в первую очередь надо как-то сохранить. 
Угол поворота шестерёнки, присутствие или отсутствие отверстия в перфоленте, намагничевание конктретных участков --- всё это может хранить информацию, для дальнейшиго использования.
Но это были способы хранить информацию в энергонезависимых ячейках памяти.
Для большой скорости чтении и записи используются энергозависимые ячейки.
Одна из самых простых энергозависимых ячеек --- триггер. Есть много видов триггеров, разберём самый простой вид --- RS, продемонстрированный на рисунке \ref{img:rs-trigger.png}. 

\includeimage
    {rs-trigger.png}
    {f}
    {H}
    {0.5\textwidth}
    {RS--триггер}

Данный тригер имеет два входа Set и Reset и два выхода Q и не Q. 
Этот триггер можно создать двумя способами: через элементы И-НЕ и ИЛИ-НЕ.
Если составить таблицы истинности, то получим 4 состояния триггера: установка единицы, установка нуля, сохранения предырущего результата и запрещённое состояние. 
С первыми тремя всё просто, четвёртое состояние ни в коем случае не должно уктивироваться, так как в противном случае триггер будет переключается от одного сотояния к другому.

Рассмотрим ещё одни триггер. 
Его УГО и создание на базовых ЛЭ представлено на рисунке \ref{img:d-trigger}.
D-триггер отличается от RS тем, что вместо входов установки и сброса, триггер имеет вход данных и вход активации.

\includeimage
    {d-trigger}
    {f}
    {H}
    {0.5\textwidth}
    {D--триггер}

\section{Счётчики, шифратор, дешифратор, мальтиплексор}

Счётчик --- устройство для счёта в плюс или в минус в зависимости от подключения.
Чтобы собрать простейший счётчик на 4, достаточно последовательно соединить 2 D--триггера. 
Выход $\overline{Q_0}$ подключаем ко входу D.
Таким образом D-- триггер становится T--триггер.
Выходы $Q_0$ и $Q_1$ станут выходами счётчика.
Первый счётчик будет отвечать за младший бит, последующие --- за старшие.

Шифратор --- устройство, шифрирующее один из N входов в двоично число, равное номеру этого входа.
Главное правило шифратора --- только один вход может иметь логическую единицу при примом входе.
Таблица истинности и УГО шифратора изображены на рисунке \ref{img:coder}

\includeimage
    {coder}
    {f}
    {H}
    {0.8\textwidth}
    {Шифратор 8-3}

Дешифратор работает противоположным образом. 
Используя N входов и $2^N$ выходов, устройство преобразует двоичное число в один из активных выходов.
На рисунке \ref{img:decoder} показаны УГО дешифратора, таблицу истинности и схему на простейших ЛЭ.

\includeimage
    {decoder}
    {f}
    {H}
    {0.8\textwidth}
    {Дешифратор 2-4}

Мультиплексор --- устройство, которое имеет N входов адреса, $2^N$ входов данных и один выход.
Когда на шину адреса подаётся число, оно дешифрируется и с полученного номера входа данных снимается значение, которое выставляется на выходе.
УГО мультиплексора представлен на рисунке \ref{img:multiplex}

\includeimage
    {multiplex}
    {f}
    {H}
    {0.8\textwidth}
    {Мультиплексер}

\section{Программа и исполняемый код}

Так как же компьютер понимает программы?
Послевим в линию триггеры и разобьём на группы по 8.
Таким образом плочим ячейки по байту информации.
Введём счётчик команд, который будет хранить адрес ячейки, содержащию номер действия --- команды.
Байт адреса поступает на дешифратор, который осуществяет выборку.
Выбранный байт дешифрируется в сигнал дествия.
Один из действий может быть суммирования два байти и запись в ячейку памяти.


\section{Преобразования текста в код}

Когда программист пишет программу, на самом деле он пишет обычный текст, который потом переводится в понятные компьютеру команды.
Языки Программирования (ЯП) бывают двух типом: компеллированные и интрепритированые.
Компелированные языки --- языки, програама на которых написана проходит этапы преобразований в двоичный код.
Интерпритированные --- языки, код которых преобразуется в цепочки терм, которые поступают на вход программе--интерпритатора.

В рамках данной книги поговорим только об компилированных языках.
Для языка Си преобразование текста в винарный код происходит в 4 этапа.


\begin{enumerate}
\item Препроцессинг --- процесс преодбразования текста программы с макрасами в текст буз макросов.
\item Компиляция --- копирование всех заголовочных файлов для образования связок функций, а именно их прототипы с реализацией. Весь текст переводится в язык ассемблера.
\item Ассемблирование --- преобразование языка ассемблера в бинарный код. Файл становится объектным.
\item Линковка --- Сбор всех объектних файлов и файлов-библиотек. После этого процесса получаем исполняемый файл.
\end{enumerate}

\includeimage
    {compile_list}
    {f}
    {H}
    {1\textwidth}
    {Компиляция}


\begin{comment}

\begin{lstlisting}
for (int i = 0; i < iterations; i++)
{
	do something
}
\end{lstlisting}

\end{comment}

\chapter{Основы языка Си}
%история создания
\section{Первая программа. Ввод и вывод.}

Напишем самую простую программу на языке Си.
В следующем листинге приведена самя проста программа на языке Си.
В первой строчке, используя макросс include, фуйлу сообщается библиотесный файл, в котором могут находится функции, отсутствующие в основном файле.

Оставшийся код --- функция main. 
Данная функция является начальной точкой программы.
Функция принимает количество агрументов и сми аргументы при запуске программы.
Возвражает данная функция 0 --- код успешного завершения программы.
Функция puts принимает строку и выводит этот текст в консоль при запуске программы. 

\begin{lstlisting}
#include "stdio.h"

int main(int argc, char *argv[])
{
    puts("Hello world!");
    return 0;
}
\end{lstlisting}

Ввод и вывод осуществялест через функции scanf и printf.


\section{Статические типы данных}
\subsection{Простые типы данных}
В языке Си не так много базовых типов данных, как может показаться с начала. Так как мы помним, что Си --- это более приятный язык для чтения, чем язык ассемблера, то и типов данных в нём не больше. Основные типы --- это:
\begin{itemize}
\item char   -- размером в один байт, хранящий символ из таблицы (ASCII)
\item int    -- размеров в 4 байта, хранящий знаковое число
\item float  -- размеров в 4 байта, хранящий дробное знаковое число
\item double -- тоже самое, что и float, только в размер в два раза больше.
\end{itemize}
Также к эти типы можно модифицировать с помощью слов "long", что даст размер в два раза больше для типа данных int, и unsigned --- которое пометит переменную, как безнаковую.

%разница в инициализации и присвоения.

\subsection{Статические массивы}

\begin{comment}
\begin{lstlisting}[caption={}, label={lst:},]
\end{lstlisting}
\end{comment}

\subsection{Текстовые строки}
\subsection{Структуры}
\section{Условные операторы и операторы смены направления}

Под условными операторами подразумеваются команды if/else if/else. 
Данные команды имеют следующий синтаксис.


\begin{lstlisting}[caption={Условный оператор}, label={lst:if},]
if (bool1) 
{
    do 1
}  
else if (bool2) 
{
    do 2
} 
else 
{
    do 3
}
\end{lstlisting}

Если условие 1 выполнится, то выполнится действие 1.
Если первое условие не выполняется, то последовательно оправшиваются оставшиеся условия, пока не всретят первое верное.
Если такого условия нет, то ветка else полнится обязательно.

Другой способ перенаправления управления --- switch/case.
В отличие от условий, switch работает следующем образом. 
Из переменной varyable считывается значение и последовательно сравнивается с константами const1-const4.
Данные константы должны быть известны при компиляции программы.
Если varyable и константа равны, то начинается выполнение блока.
В конце блока должен быть break, иначе полсе выполнения N блока начнётся веполнение N+1 блока.
Default выполняется при условии, что ни один case не обработан.

Для демонстрации работаспособоности рассмотрим листинг \ref{lst:switch_case}.

\begin{lstlisting} [caption={Switch/case}, label={lst:switch_case},]
switch ( varyable ) {
case const1:
    do something 1
    break;
case const2:
    do something 2
    break;
case const3:
    do something 3
case const4:
    do something 4
    break;        
default:
    do something 5
    break;
}
\end{lstlisting}

Интерес предстваляет случай, когда varyable равен третьей константе.
Дело в том, что если будет это равнство, то вместо выполнения действия 3, выполнится действия 3 и 4.
Если бы поле 4 дейстия не было бы break, то программа стала выполнять последовательно все действия до первого появления break.

Стоит упомянуть, что есть ещё один способ поменять управление программы.
Я говорю о наследованным с языка ассамблера команде goto.
Эта команда безусловного перехода на метку, которую укажут после этой команды.
Минусы этой команды --- её использование запутывает логику работы программы и дальнейшее создание непредсказуемого поведения.
На самом деле есть несколько случаев, когда использование goto немного ускоряет работу программы, но при правильном проектировании логики таких случаев можно избежать.

\section{Циклы}

Цикл --- оператор исполнения кода N количество раз.

В языке Си используются 3 вида циклов: универсальный, пока и пока не.
Универсалььный цикл или цикл for используется чаще всего.
Он состоит из 4 блоков: инициализация начальных значений, условие выхода, блок изменения значений на каждой итерации (в простейшем случае инкрементация счётчика) и блок действия.



\section{Процедуры и функции}
\section{Рекурсия}
\section{Динамические типы данных}
\subsection{Динамические массивы}
\subsection{Списки}
\subsubsection{Очередь}
\subsubsection{Стек}
\section{Задачи}

\chapter{С++}
\section{Отличие Си и С++}
\section{Три столпа ООП}
\section{}



\end{document}

