\documentclass{bmstu}
\usepackage{xparse}
\usepackage{comment}
\usepackage{amsmath} 
\setcounter{tocdepth}{3}
\setcounter{secnumdepth}{3}

\usepackage{hyperref}
\hypersetup{
    colorlinks,
    citecolor=black,
    filecolor=black,
    linkcolor=black,
    urlcolor=black
}

%\lstset { %    
%	language=C++,    
%	backgroundcolor=\color{black!5}, % set backgroundcolor    
%	basicstyle=\footnotesize,% basic font setting
%	}

\lstset{
        inputencoding=utf8/koi8-r,
        basicstyle=\small\ttfamily,
        rulecolor=\color{black},
        escapeinside={\%*}{*)},
        breaklines=true,
        breakatwhitespace=true,
        tabsize=4,
        showstringspaces=false,
        float=h!,
        abovecaptionskip=-5pt,
        backgroundcolor=\color{black!5},
        frame=single,
}



\begin{document}

\tableofcontents
 



\chapter{Что такое компьютер}
\section{Немного истории}
Перед тем, как изучать языки программирования стоит понять ....

Для начала ответим на вопрос: "Что такое компьютер" ? Для повседневного обывателя это покажется очевидным, но давайте порасуждаем. 
Если обратится к свободным источникам(например к википедии), то мы увидем множество меканизмов. 
Саммым ранним компьютером я бы назвал антикитерский механизм. 
Всего лишь несколько десятков шестерёнок и магия простых чисел позволяло этому устройству предстакзыать лунные и солнечные затмения, движения небесных объектов и это при условии, что Земля была установлена, как центр отсчёта. 
При таком расположенни планеты, движения всех оставишся объектов перестовало быть простым объединением множества элемтических орбит. 
Так чтоже такое компьютер? Компьютер - это калькулятор. Даже сейчас, спустя полтысячелетия, компьютер остаётся сложным калькулятором, в основе которого стоит сложение, побитывые сдвиги и другие простые операции. 

Рассмотрим простой счётный механизм, состоящий из шетерёнок, рычагов и циферблатов. 
Для начала установим следующие правила: система счисления у нашего компьютера будет позиционной и, для удобства, оставим её десятичной, будет три поля для данных - два для входа и один для выхода. 
Тогда, выствавив два входных числа и использовав набор шестерёнок для передачи момента от входа к выходу, можно легко получить две простейших операции. 


\section{Диоды}

Начнём с самого простого --- с диодов. Диод --- это плоупроводник, содержащий в себе примесь, которая увеличивает 
или уменьшает количество свободных зарядов. 
Из школьного курса физики можно вспомнить, что диод пропускает ток только в одном направлении. 
Это несовсем верно, но пока приним за истину. 
Посмотрим на рисунок \ref{img:diod.png} и изучем, как ведут себя электроны в диоде при отсутствии внешнего питания. 
Слева зона богатая дырками (или носителями положительных зарядов), справа - электронами. 
Электроны могут перемещаться двумя способами: дрейфовый и диффузионный ток. 
Дрейфовый ток возникате из--за разницы потенциалов, диффузионный --- из--за разницы концентраций положительных и  отрицательных свободных зарядов.
На границе областей образуется запирающий слой. 
Этот слой не полволяет электорнам из n облости перейти в зону p.  

\includeimage
    {diod.png}
    {f}
    {H}
    {1\textwidth}
    {Диод}

Подключим питание: к p области подключим положительное питание, к области n --- отрицательное. 
Таким образом питание создаёт достаточное поле для образования дрейфового тока. Диод находится с открытом состоянии.
При противоположном подключении поле будет воздействовать на запирающий слой, расширяя его.
Рассмотрим вольт-амперную харатеристику на рисунке \ref{img:vah.jpg}. 
Как можно увидеть, при отрицательном напряжении появляется обратный ток. 
Поначалу он незначительный, но при большом напряжении этот ток резко возрастает и возникает пробой.
Хуже всего, если пробой тепловой. В таком случае устройство выходит из строя и больше не вернётся в рабочее состояние.
При других пробоях, при небольших временныйх интервалах устройство будет работуть корректно. 

\includeimage
    {vah.jpg}
    {f}
    {H}
    {1\textwidth}
    {Вольт-амперная характеристика}


\section{Транзисторы}

Если упрастить схему, то транзистор есть пара диодов, подключенных одноимёнными концами дрег к другу.
Из этого следует, что транзисторы могут быть двух видов: p-n-p и n-p-n типов.
У транзостора есть три ноги: эмитор, коллектор и база. 
Электроны движутся от эмитора к коллектору при обкрытом транзисторе.
Транзистор открывается, когда на базу транзистора n-p-n типа втикает в ток. 
Если трензистор p-n-p типа, то для открытия ток должен вытикать с базы.  

В современном мире бОльшая часть аппаратуры основана на Транзисторно-Транзисторной (ТТЛ) логике.
Транзистор играет роль ключю, позволяя перенаправлять ток и последовательно задействовать нужные Логические Элементы (ЛЭ).

\section{Простые логические элементы}

В булевой алгебре есть такие операции, как коньюкция (логическое умножение), дизъюнкия (логическое сложение) и отрицание. 
Но математика --- это матиматике, а как физически получить булевые функции для выполнения этих опаций.
Рассмотрим рисунк \ref{img:le.jpg}, на нём можно увидеть 3 логических элементов: логическое НЕ или инвертор, И-НЕ и ИЛИ-НЕ.

\includeimage
    {le.jpg}
    {f}
    {H}
    {1\textwidth}
    {Логические элементы}

Разберём работу инвертора, представленного на рисунке \ref{img:not.jpg} (остальные элементы предлагается разобрать читателям самостоятельно). 

\includeimage
    {not.jpg}
    {f}
    {H}
    {0.5\textwidth}
    {Логическое отрицание}

В инверторе используестся транзистор n-p-n типа, следовательно, когда через базу потечёт ток, транзистор откроется.
Пусть входное напраяжение на входе равно 0.
Тогда через базу ток не течёт и транзистор окажется в зактрытом состоянии.
Ток от коллектора к эммитору течь не будет и напряжение $E_K$, пройдя резистор $R_K$, сгененрирует выходное напряжение.
Тем самым, при подачи логического нуля на выходе получим логическую единицу.
Если подать на вход +5 вольт --- эквивалент логической единицы, то в базу начнёт втикать электрический ток и транзистор откроется. 
Тогда через транзитор потечёт ток и на выходе будет напряжение логического нуля.

\section{Память. Триггеры.}

Чтобы обработать какую-либо информацию, её в первую очередь надо как-то сохранить. 
Угол поворота шестерёнки, присутствие или отсутствие отверстия в перфоленте, намагничевание конктретных участков --- всё это может хранить информацию, для дальнейшиго использования.
Но это были способы хранить информацию в энергонезависимых ячейках памяти.
Для большой скорости чтении и записи используются энергозависимые ячейки.
Одна из самых простых энергозависимых ячеек --- триггер. Есть много видов триггеров, разберём самый простой вид --- RS, продемонстрированный на рисунке \ref{img:rs-trigger.png}. 

\includeimage
    {rs-trigger.png}
    {f}
    {H}
    {0.5\textwidth}
    {RS--триггер}

Данный тригер имеет два входа Set и Reset и два выхода Q и не Q. 
Этот триггер можно создать двумя способами: через элементы И-НЕ и ИЛИ-НЕ.
Если составить таблицы истинности, то получим 4 состояния триггера: установка единицы, установка нуля, сохранения предырущего результата и запрещённое состояние. 
С первыми тремя всё просто, четвёртое состояние ни в коем случае не должно уктивироваться, так как в противном случае триггер будет переключается от одного сотояния к другому.

Рассмотрим ещё одни триггер. 
Его УГО и создание на базовых ЛЭ представлено на рисунке \ref{img:d-trigger}.
D-триггер отличается от RS тем, что вместо входов установки и сброса, триггер имеет вход данных и вход активации.

\includeimage
    {d-trigger}
    {f}
    {H}
    {0.5\textwidth}
    {D--триггер}

\section{Счётчики, шифратор, дешифратор, мальтиплексор}

Счётчик --- устройство для счёта в плюс или в минус в зависимости от подключения.
Чтобы собрать простейший счётчик на 4, достаточно последовательно соединить 2 D--триггера. 
Выход $\overline{Q_0}$ подключаем ко входу D.
Таким образом D-- триггер становится T--триггер.
Выходы $Q_0$ и $Q_1$ станут выходами счётчика.
Первый счётчик будет отвечать за младший бит, последующие --- за старшие.

Шифратор --- устройство, шифрирующее один из N входов в двоично число, равное номеру этого входа.
Главное правило шифратора --- только один вход может иметь логическую единицу при примом входе.
Таблица истинности и УГО шифратора изображены на рисунке \ref{img:coder}

\includeimage
    {coder}
    {f}
    {H}
    {0.8\textwidth}
    {Шифратор 8-3}

Дешифратор работает противоположным образом. 
Используя N входов и $2^N$ выходов, устройство преобразует двоичное число в один из активных выходов.
На рисунке \ref{img:decoder} показаны УГО дешифратора, таблицу истинности и схему на простейших ЛЭ.

\includeimage
    {decoder}
    {f}
    {H}
    {0.8\textwidth}
    {Дешифратор 2-4}

Мультиплексор --- устройство, которое имеет N входов адреса, $2^N$ входов данных и один выход.
Когда на шину адреса подаётся число, оно дешифрируется и с полученного номера входа данных снимается значение, которое выставляется на выходе.
УГО мультиплексора представлен на рисунке \ref{img:multiplex}

\includeimage
    {multiplex}
    {f}
    {H}
    {0.8\textwidth}
    {Мультиплексер}

\section{Программа и исполняемый код}

Так как же компьютер понимает программы?
Послевим в линию триггеры и разобьём на группы по 8.
Таким образом плочим ячейки по байту информации.
Введём счётчик команд, который будет хранить адрес ячейки, содержащию номер действия --- команды.
Байт адреса поступает на дешифратор, который осуществяет выборку.
Выбранный байт дешифрируется в сигнал дествия.
Один из действий может быть суммирования два байти и запись в ячейку памяти.


\section{Преобразования текста в код}

Когда программист пишет программу, на самом деле он пишет обычный текст, который потом переводится в понятные компьютеру команды.
Языки Программирования (ЯП) бывают двух типом: компеллированные и интрепритированые.
Компелированные языки --- языки, програама на которых написана проходит этапы преобразований в двоичный код.
Интерпритированные --- языки, код которых преобразуется в цепочки терм, которые поступают на вход программе--интерпритатора.

В рамках данной книги поговорим только об компилированных языках.
Для языка Си преобразование текста в винарный код происходит в 4 этапа.


\begin{enumerate}
\item Препроцессинг --- процесс преодбразования текста программы с макрасами в текст буз макросов.
\item Компиляция --- копирование всех заголовочных файлов для образования связок функций, а именно их прототипы с реализацией. Весь текст переводится в язык ассемблера.
\item Ассемблирование --- преобразование языка ассемблера в бинарный код. Файл становится объектным.
\item Линковка --- Сбор всех объектних файлов и файлов-библиотек. После этого процесса получаем исполняемый файл.
\end{enumerate}

\includeimage
    {compile_list}
    {f}
    {H}
    {1\textwidth}
    {Компиляция}


\begin{comment}

\begin{lstlisting}
for (int i = 0; i < iterations; i++)
{
	do something
}
\end{lstlisting}

\end{comment}

\chapter{Основы языка Си}
%история создания
\section{Первая программа. Ввод и вывод.}

Напишем самую простую программу на языке Си.
В следующем листинге приведена самя проста программа на языке Си.
В первой строчке, используя макросс include, фуйлу сообщается библиотесный файл, в котором могут находится функции, отсутствующие в основном файле.

Оставшийся код --- функция main. 
Данная функция является начальной точкой программы.
Функция принимает количество агрументов и сми аргументы при запуске программы.
Возвражает данная функция 0 --- код успешного завершения программы.
Функция puts принимает строку и выводит этот текст в консоль при запуске программы. 

\begin{lstlisting}
#include "stdio.h"

int main(int argc, char *argv[])
{
    puts("Hello world!");
    return 0;
}
\end{lstlisting}

Ввод и вывод осуществялест через функции scanf и printf.


\section{Статические типы данных}
\subsection{Простые типы данных}
В языке Си не так много базовых типов данных, как может показаться с начала. Так как мы помним, что Си --- это более приятный язык для чтения, чем язык ассемблера, то и типов данных в нём не больше. Основные типы --- это:
\begin{itemize}
\item char   -- размером в один байт, хранящий символ из таблицы (ASCII)
\item int    -- размеров в 4 байта, хранящий знаковое число
\item float  -- размеров в 4 байта, хранящий дробное знаковое число
\item double -- тоже самое, что и float, только в размер в два раза больше.
\end{itemize}
Также к эти типы можно модифицировать с помощью слов "long", что даст размер в два раза больше для типа данных int, и unsigned --- которое пометит переменную, как безнаковую.

%разница в инициализации и присвоения.

\subsection{Статические массивы}

Статический массив или прото массив --- это последовательнойсть однотипных данных.
Ображение к массиву осуществляется посредству значений указателя базы и смещения.
Рассмотрим код в лиcтенге \ref{lst:static_array}

\begin{lstlisting}[caption={Статический массив}, label={lst:static_array},]
int array[N];
for (int i = 0; i < N; ++i)
{
    array[i] = 2;
}
\end{lstlisting}

В первой строчке был объявлен статический массив на N элементов. 
Внутри цикла array --- указатель на базу массива, i --- индекс или смещение от базы.
Затем, с помощью универсального цикла, каждому элементу саммивы было присвоено значение 2, как значению.

\subsection{Текстовые строки}

Строка --- это последовательность символов.
Если символ --- это char, то строка есть не что иное, как массив символьных переменных.
В тексте предожения имеют следующую структуну: начало предолжения начинается с заглавного символа, конец оканчивается точкой, вопросительным или восклицательным знаком.
В Си начало строки определено первым символом или нулевым индексом(смещением), конец строки вместо точки является код 0x00.
Проанализируем строку в листинге \ref{lst:string}

\begin{lstlisting}[caption={Простейшая строка}, label={lst:string},]
char string[13] = "Hello World!";
\end{lstlisting}

Строка "Hello World!" содержит 12 символов текста. 
Тринадцатый символ --- 0x00.

\subsection{Структуры}

На данный момент мы знакомы с базовыми типами данных, но что делать, когда есть потребность работать с несколькими типами, как атриутами сущности?
Навырочку придут стректуры.
Структура --- это тип данных, который несёт в себе множество переменных различных типов --- полей.
Рассмотрим структуру персоны в листинге \ref{lst:struct}.

\begin{lstlisting}[caption={Структура персоны}, label={lst:struct},]
struct Person
{
    char first_name[255];
    char second_name[255];
    unsigned int year;
};
struct Person person = {"First", "Second", 40};
\end{lstlisting}

В листенге была создана структура с полями: имя, фамилия, возраст.
В последней строчке создали переменную person типом данных Person.
Поля этой переменной проинициализированы именем First, фамилией Second и возрастом в 40 лет.
Для обращения к полям этой структуры используется точечная нотация ($person.first\_name = "new\_first\_name";$). 

\subsection{Перечисление}

Стоит упомянуть о таком типе данных, как перечисление.
Перечисление --- тип данных, который обычно содержитоднотипные данные-флаги.

\begin{lstlisting}[caption={Перечисление}, label={lst:enum},]
enum COLORS
{
    RED = 1,
    BLUE,
    GREEN,
    BLECK,
    YELLOW,
    WHITE,
};
struct Person person = {"First", "Second", 40};
\end{lstlisting}

В листинге \ref{lst:enum} переменная COLORS::RED содержит 1, все последующие цвета содержат на единицу больше значение предыдущего цвета.
В коде основной программы будет не принципиально значение конкретного цвета, так как сравниваться будут сами переменные.

\section{Условные операторы и операторы смены направления}

Под условными операторами подразумеваются команды "if"/"else if"/"else". 
Данные команды имеют следующий синтаксис.


\begin{lstlisting}[caption={Условный оператор}, label={lst:if},]
if (bool1) 
{
    do 1
}  
else if (bool2) 
{
    do 2
} 
else 
{
    do 3
}
\end{lstlisting}

Если условие 1 выполнится, то выполнится действие 1.
Если первое условие не выполняется, то последовательно оправшиваются оставшиеся условия, пока не всретят первое верное.
Если такого условия нет, то ветка else полнится обязательно.

Другой способ перенаправления управления --- switch/case.
В отличие от условий, switch работает следующем образом. 
Из переменной varyable считывается значение и последовательно сравнивается с константами const1-const4.
Данные константы должны быть известны при компиляции программы.
Если varyable и константа равны, то начинается выполнение блока.
В конце блока должен быть break, иначе полсе выполнения N блока начнётся веполнение N+1 блока.
Default выполняется при условии, что ни один case не обработан.

Для демонстрации работаспособоности рассмотрим листинг \ref{lst:switch_case}.

\begin{lstlisting} [caption={Switch/case}, label={lst:switch_case},]
switch ( varyable ) {
case const1:
    do_something_1
    break;
case const2:
    do_something_2
    break;
case const3:
    do_something_3
case const4:
    do_something_4
    break;        
default:
    do_something_5
    break;
}
\end{lstlisting}

Интерес предстваляет случай, когда varyable равен третьей константе.
Дело в том, что если будет это равнство, то вместо выполнения действия 3, выполнится действия 3 и 4.
Если бы поле 4 дейстия не было бы break, то программа стала выполнять последовательно все действия до первого появления break.

Стоит упомянуть, что есть ещё один способ поменять управление программы.
Я говорю о наследованным с языка ассамблера команде goto.
Эта команда безусловного перехода на метку, которую укажут после этой команды.
Минусы этой команды --- её использование запутывает логику работы программы и дальнейшее создание непредсказуемого поведения.
На самом деле есть несколько случаев, когда использование goto немного ускоряет работу программы, но при правильном проектировании логики таких случаев можно избежать.

\section{Циклы}

Цикл --- оператор исполнения кода N количество раз.

В языке Си используются 3 вида циклов: универсальный, пока и пока не.
Универсалььный цикл или цикл for используется чаще всего.
Он состоит из 4 блоков: инициализация начальных значений, условие выхода, блок изменения значений на каждой итерации (в простейшем случае инкрементация счётчика) и блок действия.

В листинге \ref{lst:for} блок инициализации содержит "<int i = 0">, 
блок условия выхода --- "<i < n">, блок итерации --- "<++i">.
Пока значение i меньше n, do\_something будет выполняться.

\begin{lstlisting} [caption={Цикл for}, label={lst:for},]
for (int i = 0; i < n; ++i)
{
    do_something;
}
\end{lstlisting}

Менее редкий цикл пока "<while">. 
Вначале пишется условие и пока оно выполняется, тело цикла будет раз за разом итерироваться.
Выход из этого цикла осущетвляется либо ложного значение условий или через слово break, но его лучше не использовать.

\begin{lstlisting} [caption={Цикл while}, label={lst:while},]
while (a > b)
{
    do_something;
}
\end{lstlisting}

Третий тип цикла --- do while.
Его особенность в том, что этот цикл выполнится хотя бы один раз.
Дальнейшее выполнение происходит только при выполнении конечного условия.

\begin{lstlisting} [caption={Цикл do while}, label={lst:do_while},]
do 
{
    do_something;
} while (a > b);
\end{lstlisting}

\section{Процедуры и функции}

Процедура --- участок кода, который можно вызвать из программы для выполнения определённых операци.
Вызов может может проходить как с параметрами, так и без них.
Функция --- тоже самое, за исключение того, что функция может вернуть данные.

В Си есть только функции. 
Когда нужна процедура, то вызывается функция с пустым возвратом.

Из функции можно вернуть любой тип данных, как базовый, так и собственный.
В функцию данные передаются двумя способами: по значению и по ссылке.
Если значение передаётся по значение, то это значит, что мы копируем данные из переменнй в аргумент функции.
Если значение передаётся по ссылке, то в аргумент копируется адрес переменной.
Таким образом, если нужно в функции работать с внешними данными, то передавать их надо по ссылке.
Также передача по ссылке является желательным при передачи больших структур, так как их копирование является очень дорогой операцией.

Пример функции представлен в листинге \ref{lst:function}.

\begin{lstlisting} [caption={Объявление функции}, label={lst:function},]
type nameFunction(type_1 arg1, type_2 *arg2)
{
    type value;
    return value;
}
\end{lstlisting}

\begin{lstlisting} [caption={Вызов функции}, label={lst:call_function},]
type_1 arg1;
type_2 arg2;
nameFunction(arg1, &arg2)
\end{lstlisting}

Таким образом при вызове функции, внутри функции первый аргумент будет хранить копию информации яцейки arg1,
а второй --- копию указателя на ячейку arg2. 
При обработки и изменении этих двух аргументов внутри функции и выхода из неё, первый аргумент останенся неизменным, а второй сменит своё значение. 

\section{Рекурсия}

Для многих рекурсия кажется чем-то сложным и запутанным, хотя это не так.
Рекурсия --- это функция, которая вызывает сама себя.
У рекурсии две главные части: условие выхода из функции и вызов себя.
Рассмотрим простейший пример использования рекурсии в поиске факториала в листинге \ref{lst:factoryal}

\begin{lstlisting} [caption={Функция нахождения факториала}, label={lst:factoryal},]
uint32_t fact(uint32_t value)
{
    if (value < 2)
    {
        return 1;
    }
    return value * fact(--value);
}
\end{lstlisting}

Таким образом, когда мы вызовем эту функцию от 5, то наша программа вызовет функцию от 5, потом функцию от 4, от 3, 2, 1 и затем начнёт свёртку.
В итоге получим 5 * (4 * (3 * (2 * (1)))) = 120.
Смотря на этот пример возникает вопрос: "< А зачем так заморачиваться, когда можно сделать проще через цикл?">
На самом деле проще, но только для этого примера.
Рекурсия полезна в обработке графов.
Каждый раз, когда человек решает задачу и может выделить в ней блок, который связан с другими блоками, можно применить рекурсию.
Когда мы затронем тему списков и деревьев, рекурсия будет лучшим решением для обхода графа или очистки данных. 

\section{Динамические типы данных}

Под динамическим типом данных подразумеваются типы данных, которые напрямую работают с кучей.
Такие типы нужны тогда, когда мы на этапе компиляции не знаем сколько памяти нужно выделить.

Для начала работы необходима выделить память на N байт.
В языке Си есть несколько способов выделения памяти.
Рассмотрим 3 функции malloc, calloc и realloc.
Первая выделяет память на N байт. 
Внутри этого пространства находится мусор.
Вторая --- при выделении памяти все байты зануляются.
Третья --- расширяет выделенную память.
Если в конце блока есть свободное пространство, то блок просто расширится.
Если места не хватает, то в куче выделяется новый блок размером старого блока и колличесвтом байт для расширения.
После, в новую облость копируются байты из старого блока.
Затен удаляется старый блок и возвращаятся указатель на новый.

Когда динамическая структура больше не нужна, её следуюет очистить из памяти.
Если этого не сделать, то произойдёт утечка памяти.
Это значит, что в оперативной памяти раз за разом будет выделяться блок памяти и в конечном итоге ОЗУ не сможет предоставить свободного места, что приведёт к завианию программы или операционной системы в худшем случае.

Чтобы очистить память в языке Си есть функция free, которая принимает указатель и очищает память по этому указателю.
Сам указатель после выполнения функции ссылается на туже ячейку памяти, однако попытка обратится к данным по этому адресу приведёт к ошибки сегментации памяти.
Это защитный механизм, чтобы приложения работали только с теми данными, которые относятся к этому приложению.

\subsection{Динамические массивы}

Динамический массив --- массив, размер которого определяется программно.
При компиляции программы в сегмент данных помещается указатель на массив. 
Изначально в массив рекомендовано установливать значение NULL.
Такие образом можно избежать попадания мусора в этот указатель для дальнейших проверок. 
Для дальнейшей работы потребуется выделить память на N элементов.
Индексация массива осуществляется темже способом, как и при статическом массиве.
Пример работы с динамическим массивом приведена в листинге \ref{lst:dynamic_array}.

\begin{lstlisting} [caption={Динамический массив целых чисел}, label={lst:dynamic_array},]
int *array = malloc(N * sizeof(int));
for (int i = 0; i < N; ++i)
{
    array[i] = i;
}
free(array);
\end{lstlisting}

\subsection{Списки}
\subsubsection{Очередь}
\subsubsection{Стек}
\subsubsection{Бинароное дерево}

\section{Задачи}

\chapter{С++}
\section{Отличие Си и С++}
\section{Три столпа ООП}
\section{Классы}
\section{Виртуальные методы}
\section{}
\section{Перегрузка операторов}
\section{Шаблоны}
\section{Сложный полиморфизм}
\section{}


\end{document}

